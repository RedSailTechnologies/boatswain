#############
### NOTES ###
#############
# Everything in an array other than the clusters list can be substituted for a template, to
# include: apps, tests, triggers, and strategies.

# This means that a deployment can be an aggregation of a bunch of different templates, overwriting
# and specifying values as needed either by an input file or parameters from triggers

# .Inputs vs .Parameters
# Inputs come from merging a template with another file when setting up a deployment, or specified
# when calling a template from another template. An easy way to think of them are compile-time variables.
# Parameters on the other hand are decidedly runtime variables-coming from trigger inputs or manually
# specified values at runtime.


################
### METADATA ###
################

# the version of this deployment, note this won't impact parts of the deployment
# unless they use it but it should probably be unique for each deployment
version: ${{ .Parameters.version }}

# the names of clusters currently configured in bosn - these can be added through 
# the ui or specified as a configuration file on installing bosn but must be in
# this list prior to execution of the deployment
clusters:
  - dev
  - staging

# apps are one of the objects we can use in a strategy, meant for long-lived applications/changes
apps:
  - name: sample-app # the name of the app, used with helm and with bosn output
    helm: # specifics of this application
      chart: sample-app # the name of the chart for the app
      repo: myrepo # the name of the helm repo, note this must be configured in bosn
      version: ${{ .Parameters.sampleAppChartVersion }} # the version of the chart, note the template syntax
  
  # the name of another template in boatswain, note the path@branch syntax
  - template: path/to/default-app.yaml@branch
    repo: git-repo # name of the git repo to find this template in
    # these will populate in the template under the Inputs object
    arguments:
      version: '1.0.1' # example usage inside the template: ${{ .Inputs.version }}

# tests are another object we can use in a strategy, not meant to be long lived, but otherwise are
# the same as apps in their specs
tests:
  # tests can be specified much like an app, the expectation here is that this is a job or 
  # collection of jobs, and after the install with wait the tests should be done
  - name: sample-app-load
    helm:
      name: sample-app
      timeout: 10m # similar to the --timeout flag for helm test, defaults to 5m


#################
### EXECUTION ###
#################

# triggers are what start the strategy's execution, all must be met for the trigger to fire
triggers:
  # deployments can trigger other deployments
  - deployment: 
      name: named-deploy-trigger # the other deployment's name
  
  # trigger a deployment by the rpc/json call, calling this deployment name and sending required params
  - web:
      name: mywebtrigger
        
  # trigger a deployment manually
  - manual:
      groups:
        - fun.squad
      users:
        - some.body
        - i.used
        - to.know

# strategy is the backbone of the execution flow that specifies how deployments and tests are run
strategy:
  - name: deploy-app
    always:
      # run an app deployment from above
      - app: 
          name: sample-app
          cluster: dev
          helm:
            command: upgrade # install, upgrade, rollback, uninstall - defaults to install
            wait: true # whether to deploy helm with the wait flag, defaults to false
            values:
              # specify the values individually
              raw:
                someValue: ${{ .Parameters.someValue }}
                # ...

      # also run this app deployment, note that within a strategy entry no guarantee is made about execution,
      # so this chart could be installed before the chart above
      - app: 
          name: sample-routing
          cluster: dev
          helm:
            wait: false
            values:
              # use part or all of a library chart as values
              library:
                chart: sample-routing-values
                repo: myrepo
                version: '10.0.2'
                files:
                  - sample-app.yaml

  # this step will run after the previous step, note that the success and failure
  # conditions depend on all portions of the previous step
  - name: run-tests
    hold: 10m # a wait, executed before any conditional-defaults to 0m
    success:
      - test: 
          name: sample-app-tests
          cluster: dev
    failure:
      - app: 
          name: sample-app
          cluster: dev
          helm:
            # whether or not to uninstall the app in question
            # note that this takes precedence over rollback!
            command: uninstall
      - app: 
          name: sample-routing
          cluster: dev
          helm:
            command: rollback
            version: '2'
  
  - name: approvals
    hold: 2h
    any:
      # approvals are how specific parts of a deployment can require manual intervention
      # note the hold happens before the approval is accepted but any parts of this step following
      # the approval are gated
      - approval:
          groups:
            - group-name # groups that can approve/start this trigger
          users: 
            - some-body # same for groups but with users
      - test: 
          name: runs-after-approval-is-met
          cluster: dev
  
  # run this step no matter what the previous condition was if the previous condition was run
  - name: trigger-following
    any:
      # trigger another deployment by using its name and the trigger name
      - trigger:
          name: another-app-deployment-trigger
          deployment: another-app
          arguments: 
            a: b

  # run this step always, regardless of whether the previous condition was run
  - name: cleanup
    always:
      - app: 
          name: sample-app
          cluster: staging
          helm: 
            wait: true
 