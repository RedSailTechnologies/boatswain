#############
### NOTES ###
#############
# Everything in an array other than the clusters list can be substituted for a template, to
# include: apps, tests, triggers, and strategies.

# This means that a deployment can be an aggregation of a bunch of different templates, overwriting
# and specifying values as needed either by an input file or parameters from triggers

# .Inputs vs .Parameters
# Inputs come from merging a template with another file when setting up a deployment, or specified
# when calling a template from another template. An easy way to think of them are compile-time variables.
# Parameters on the other hand are decidedly runtime variables-coming from trigger inputs or manually
# specified values at runtime.


################
### METADATA ###
################

# the version of this deployment, note this won't impact parts of the deployment
# unless they use it but it should probably be unique for each deployment
version: ${{ .Parameters.version }}

# the names of clusters currently configured in bosn - these can be added through 
# the ui or specified as a configuration file on installing bosn but must be in
# this list prior to execution of the deployment
clusters:
  - dev
  - staging

# apps are one of the objects we can use in a strategy, meant for long-lived applications/changes
apps:
  - name: sample-app # the name of the app, used with helm and with bosn output
    helm: # specifics of this application
      chart: sample-app # the name of the chart for the app
      repo: myrepo # the name of the helm repo, note this must be configured in bosn
      version: ${{ .Parameters.sampleAppChartVersion }} # the version of the chart, note the template syntax
  
  # the name of another template in boatswain, note the path@branch syntax
  - template: path/to/default-app.yaml
    branch: branch
    repo: git-repo # name of the git repo to find this template in
    # these will populate in the template under the Inputs object
    arguments:
      version: '1.0.1' # example usage inside the template: ${{ .Inputs.version }}

# tests are another object we can use in a strategy, not meant to be long lived, but otherwise are
# the same as apps in their specs
tests:
  # tests can be specified much like an app, the expectation here is that this is a job or 
  # collection of jobs, and after the install with wait the tests should be done
  - name: sample-app-load
    helm:
      name: sample-app
      timeout: 10m # similar to the --timeout flag for helm test, defaults to 5m


#################
### EXECUTION ###
#################

# triggers are what start the strategy's execution, all must be met for the trigger to fire
triggers:
  # deployments can trigger other deployments
  - deployment: 
      name: mydeploymenttrigger
  
  # trigger a deployment by the rpc/json call, calling this deployment name and sending required params
  - web:
      name: mywebtrigger
        
  # trigger a deployment manually, note roles and users are optional but one or the other must be set
  # and they are ORed together, meaning anyone from the role or anyone in the user list can be used
  - manual:
      name: somemanualtrigger
      # one of the three bosn roles: Admin, Editor, Reader 
      # these cascade downward from Admin -> Editor -> Reader
      role: Editor
      users:
        - some.body
        - i.used
        - to.know

# strategy is the backbone of the execution flow that specifies how deployments and tests are run
strategy:
  - name: deploy-app # the name for the step in this part of the strategy
    condition: always # the condition to run this step under (always, any, succeeded, failed)
    app: 
      name: sample-app # the name of the app, from the above metadata section
      cluster: dev # the name of the cluster, which must be on the list above
      namespace: app-ns # the namespace to use
      helm:
        command: upgrade # install, upgrade, rollback, uninstall - defaults to install
        wait: true # whether to deploy helm with the wait flag, defaults to false
        values:
          # raw values just as if all children of raw were sent to helm with -f
          # note that these values will override library values if both are supplied
          raw:
            someValue: ${{ .Parameters.someValue }}

  - name: deploy-routing
    condition: succeeded
    app: 
      name: sample-routing
      cluster: dev
      namespace: app-ns
      helm:
        wait: false
        values:
          library: # use part or all of a library chart as values
            chart: sample-routing-values
            repo: myrepo
            version: '10.0.2'
            file: sample-app.yaml

  - name: run-tests
    hold: 10m # a wait, executed before any conditional-defaults to 0m
    condition: succeeded
    test: 
      name: sample-app-tests
      cluster: dev
      namespace: app-ns # the namespace the app is in
  
  - name: uninstall-app
    condition: failed
    app: 
      name: sample-app
      cluster: dev
      namespace: app-ns
      helm:
        command: uninstall
  
  - name: rollback-routing
    condition: any
    app: 
      name: sample-routing
      cluster: dev
      namespace: app-ns
      helm:
        command: rollback
        version: '2'
  
  - name: approval
    hold: 2h
    condition: any
    any:
      # approvals are how specific parts of a deployment can require manual intervention
      # note the hold happens before the approval is accepted but any parts of this step following
      # the approval are gated
    approval:
      groups:
        - group-name # groups that can approve/start this trigger
      users: 
        - some-body # same for groups but with users
  
  - name: trigger-following
    condition: any
    trigger: # trigger another deployment by using its name and the trigger name
      name: another-app-deployment-trigger
      deployment: another-app
      arguments: 
        a: b

  - name: cleanup
    condition: always
    app: 
      name: sample-app
      cluster: staging
      namespace: app-ns
      helm: 
        wait: true
 